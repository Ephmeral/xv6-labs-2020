1. 哪些寄存器保存函数的参数？例如，在`main`对`printf`的调用中，哪个寄存器保存13？
   `a0-a7` 中存放参数，`a2` 保存了 13
2. `main`的汇编代码中对函数`f`的调用在哪里？对`g`的调用在哪里(提示：编译器可能会将函数内联）

如果观看汇编的话，发现好像没有直接调用函数 `f` ，应该是做了内联优化操作

```c
000000000000001c <main>:

void main(void) {
  1c:	1141                	addi	sp,sp,-16
  1e:	e406                	sd	ra,8(sp)
  20:	e022                	sd	s0,0(sp)
  22:	0800                	addi	s0,sp,16
  printf("%d %d\n", f(8)+1, 13);
  24:	4635                	li	a2,13
  26:	45b1                	li	a1,12 //这里直接输出12了
  28:	00000517          	    auipc	a0,0x0
  2c:	7b050513          	    addi	a0,a0,1968 # 7d8 <malloc+0xea>
  30:	00000097          	    auipc	ra,0x0
  34:	600080e7          	    jalr	1536(ra) # 630 <printf>
  exit(0);
  38:	4501                	li	a0,0
  3a:	00000097          	    auipc	ra,0x0
  3e:	27e080e7          	    jalr	638(ra) # 2b8 <exit>
```
   
3. `printf`函数位于哪个地址？ `0x0000000000000630`
4. 在`main`中`printf`的`jalr`之后的寄存器`ra`中有什么值？
	`ra` 中为0x30，因为 1536 写成16进制为 0x600，而 `printf` 的地址为 0x630，所以 ra 的值为 0x30

5. 运行以下代码。

```c
unsigned int i = 0x00646c72;
printf("H%x Wo%s", 57616, &i);
```

程序的输出是什么？这是将字节映射到字符的[ASCII码表](http://web.cs.mun.ca/~michael/c/ascii-table.html)。

>输出为 `He110 World` -> 注意中间是数字`110` 不是字母 `llo`

输出取决于RISC-V小端存储的事实。如果RISC-V是大端存储，为了得到相同的输出，你会把`i`设置成什么？是否需要将`57616`更改为其他值？

>`i` 需要设置为 `0x726c6400`，`57616` 不需要更改
>
 这里为什么输出是这样，首先对与%x 是输出 16 进制 `57616` 对应的16进制就是 `0x110` 也就不需要修改
>
 而对于 i = 0x00646c72，如果将它根据ascii码表转化一下就是 `\0dlr `，`\0`表示字符串的结尾，由于小端存储，最低有效位放在低地址上，读取的时候从低地址依次往高地址读，依次得到`rld\0`，也就是输出 World 这个单词，如果是大端存储就需要反过来了

6. 在下面的代码中，“`y=`”之后将打印什么(注：答案不是一个特定的值）？为什么会发生这种情况？

```c
printf("x=%d y=%d", 3);
```

>我个人的理解：因为调用`printf`的时候只传入一个参数，另外一个参数没有设置，而调用的过程中会将寄存器的内容设置到对应的参数，因为少传入一个参数，但是在使用的过程中还是使用了两个寄存器，这就导致另外一个寄存器的值没有经过初始化，可能是在程序其他地方执行过程中保存在寄存器的一个值，所以最后打印输出的是一个不确定的值


